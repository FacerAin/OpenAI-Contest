{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _invariant=_interopRequireDefault(require(\"./utils/invariant\"));var StateUtils={get:function get(state,key){return state.routes.find(function(route){return route.key===key;})||null;},indexOf:function indexOf(state,key){return state.routes.findIndex(function(route){return route.key===key;});},has:function has(state,key){return!!state.routes.some(function(route){return route.key===key;});},push:function push(state,route){(0,_invariant.default)(StateUtils.indexOf(state,route.key)===-1,'should not push route with duplicated key %s',route.key);var routes=state.routes.slice();routes.push(route);return(0,_objectSpread2.default)({},state,{index:routes.length-1,routes:routes});},pop:function pop(state){if(state.index<=0){return state;}var routes=state.routes.slice(0,-1);return(0,_objectSpread2.default)({},state,{index:routes.length-1,routes:routes});},jumpToIndex:function jumpToIndex(state,index){if(index===state.index){return state;}(0,_invariant.default)(!!state.routes[index],'invalid index %s to jump to',index);return(0,_objectSpread2.default)({},state,{index:index});},jumpTo:function jumpTo(state,key){var index=StateUtils.indexOf(state,key);return StateUtils.jumpToIndex(state,index);},back:function back(state){var index=state.index-1;var route=state.routes[index];return route?StateUtils.jumpToIndex(state,index):state;},forward:function forward(state){var index=state.index+1;var route=state.routes[index];return route?StateUtils.jumpToIndex(state,index):state;},replaceAndPrune:function replaceAndPrune(state,key,route){var index=StateUtils.indexOf(state,key);var replaced=StateUtils.replaceAtIndex(state,index,route);return(0,_objectSpread2.default)({},replaced,{routes:replaced.routes.slice(0,index+1)});},replaceAt:function replaceAt(state,key,route){var preserveIndex=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var index=StateUtils.indexOf(state,key);var nextIndex=preserveIndex?state.index:index;var nextState=StateUtils.replaceAtIndex(state,index,route);nextState.index=nextIndex;return nextState;},replaceAtIndex:function replaceAtIndex(state,index,route){(0,_invariant.default)(!!state.routes[index],'invalid index %s for replacing route %s',index,route.key);if(state.routes[index]===route&&index===state.index){return state;}var routes=state.routes.slice();routes[index]=route;return(0,_objectSpread2.default)({},state,{index:index,routes:routes});},reset:function reset(state,routes,index){(0,_invariant.default)(routes.length&&Array.isArray(routes),'invalid routes to replace');var nextIndex=index===undefined?routes.length-1:index;if(state.routes.length===routes.length&&state.index===nextIndex){var compare=function compare(route,ii){return routes[ii]===route;};if(state.routes.every(compare)){return state;}}(0,_invariant.default)(!!routes[nextIndex],'invalid index %s to reset',nextIndex);return(0,_objectSpread2.default)({},state,{index:nextIndex,routes:routes});}};var _default=StateUtils;exports.default=_default;","map":{"version":3,"sources":["StateUtils.js"],"names":["StateUtils","get","state","route","indexOf","has","push","invariant","routes","index","pop","jumpToIndex","jumpTo","back","forward","replaceAndPrune","replaced","replaceAt","preserveIndex","nextIndex","nextState","replaceAtIndex","reset","Array","compare"],"mappings":"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","sourcesContent":["import invariant from './utils/invariant';\n\n/**\n * Utilities to perform atomic operation with navigate state and routes.\n *\n * ```javascript\n * const state1 = {key: 'screen 1'};\n * const state2 = NavigationStateUtils.push(state1, {key: 'screen 2'});\n * ```\n */\nconst StateUtils = {\n  /**\n   * Gets a route by key. If the route isn't found, returns `null`.\n   */\n  get(state, key) {\n    return state.routes.find(route => route.key === key) || null;\n  },\n\n  /**\n   * Returns the first index at which a given route's key can be found in the\n   * routes of the navigation state, or -1 if it is not present.\n   */\n  indexOf(state, key) {\n    return state.routes.findIndex(route => route.key === key);\n  },\n\n  /**\n   * Returns `true` at which a given route's key can be found in the\n   * routes of the navigation state.\n   */\n  has(state, key) {\n    return !!state.routes.some(route => route.key === key);\n  },\n\n  /**\n   * Pushes a new route into the navigation state.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at.\n   */\n  push(state, route) {\n    invariant(\n      StateUtils.indexOf(state, route.key) === -1,\n      'should not push route with duplicated key %s',\n      route.key\n    );\n\n    const routes = state.routes.slice();\n    routes.push(route);\n\n    return {\n      ...state,\n      index: routes.length - 1,\n      routes,\n    };\n  },\n\n  /**\n   * Pops out a route from the navigation state.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at.\n   */\n  pop(state) {\n    if (state.index <= 0) {\n      // [Note]: Over-popping does not throw error. Instead, it will be no-op.\n      return state;\n    }\n    const routes = state.routes.slice(0, -1);\n    return {\n      ...state,\n      index: routes.length - 1,\n      routes,\n    };\n  },\n\n  /**\n   * Sets the focused route of the navigation state by index.\n   */\n  jumpToIndex(state, index) {\n    if (index === state.index) {\n      return state;\n    }\n\n    invariant(!!state.routes[index], 'invalid index %s to jump to', index);\n\n    return {\n      ...state,\n      index,\n    };\n  },\n\n  /**\n   * Sets the focused route of the navigation state by key.\n   */\n  jumpTo(state, key) {\n    const index = StateUtils.indexOf(state, key);\n    return StateUtils.jumpToIndex(state, index);\n  },\n\n  /**\n   * Sets the focused route to the previous route.\n   */\n  back(state) {\n    const index = state.index - 1;\n    const route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n\n  /**\n   * Sets the focused route to the next route.\n   */\n  forward(state) {\n    const index = state.index + 1;\n    const route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n\n  /**\n   * Replace a route by a key.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at and updates the routes array accordingly.\n   */\n  replaceAndPrune(state, key, route) {\n    const index = StateUtils.indexOf(state, key);\n    const replaced = StateUtils.replaceAtIndex(state, index, route);\n\n    return {\n      ...replaced,\n      routes: replaced.routes.slice(0, index + 1),\n    };\n  },\n\n  /**\n   * Replace a route by a key.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at. Does not prune the routes.\n   * If preserveIndex is true then replacing the route does not cause the index\n   * to change to the index of that route.\n   */\n  replaceAt(state, key, route, preserveIndex = false) {\n    const index = StateUtils.indexOf(state, key);\n    const nextIndex = preserveIndex ? state.index : index;\n    let nextState = StateUtils.replaceAtIndex(state, index, route);\n    nextState.index = nextIndex;\n    return nextState;\n  },\n\n  /**\n   * Replace a route by a index.\n   * Note that this moves the index to the position to where the new route in the\n   * stack is at.\n   */\n  replaceAtIndex(state, index, route) {\n    invariant(\n      !!state.routes[index],\n      'invalid index %s for replacing route %s',\n      index,\n      route.key\n    );\n\n    if (state.routes[index] === route && index === state.index) {\n      return state;\n    }\n\n    const routes = state.routes.slice();\n    routes[index] = route;\n\n    return {\n      ...state,\n      index,\n      routes,\n    };\n  },\n\n  /**\n   * Resets all routes.\n   * Note that this moves the index to the position to where the last route in the\n   * stack is at if the param `index` isn't provided.\n   */\n  reset(state, routes, index) {\n    invariant(\n      routes.length && Array.isArray(routes),\n      'invalid routes to replace'\n    );\n\n    const nextIndex = index === undefined ? routes.length - 1 : index;\n\n    if (state.routes.length === routes.length && state.index === nextIndex) {\n      const compare = (route, ii) => routes[ii] === route;\n      if (state.routes.every(compare)) {\n        return state;\n      }\n    }\n\n    invariant(!!routes[nextIndex], 'invalid index %s to reset', nextIndex);\n\n    return {\n      ...state,\n      index: nextIndex,\n      routes,\n    };\n  },\n};\n\nexport default StateUtils;\n"]},"metadata":{},"sourceType":"script"}