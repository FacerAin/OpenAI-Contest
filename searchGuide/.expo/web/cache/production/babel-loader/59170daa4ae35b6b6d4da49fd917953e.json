{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.selectAssetSource=selectAssetSource;exports.resolveUri=resolveUri;var _defineProperty2=_interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));var _core=require(\"@unimodules/core\");var _pathBrowserify=_interopRequireDefault(require(\"path-browserify\"));var _PixelRatio=_interopRequireDefault(require(\"react-native-web/dist/exports/PixelRatio\"));var _urlParse=_interopRequireDefault(require(\"url-parse\"));var _AssetSourceResolver=_interopRequireDefault(require(\"./AssetSourceResolver\"));var _PlatformUtils=require(\"./PlatformUtils\");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}var assetMapOverride=(0,_PlatformUtils.getManifest)().assetMapOverride;function selectAssetSource(meta){if(assetMapOverride&&assetMapOverride.hasOwnProperty(meta.hash)){meta=_objectSpread({},meta,{},assetMapOverride[meta.hash]);}var scale=_AssetSourceResolver.default.pickScale(meta.scales,_PixelRatio.default.get());var index=meta.scales.findIndex(function(s){return s===scale;});var hash=meta.fileHashes?meta.fileHashes[index]||meta.fileHashes[0]:meta.hash;var uri=meta.fileUris?meta.fileUris[index]||meta.fileUris[0]:meta.uri;if(uri){return{uri:resolveUri(uri),hash:hash};}var assetUrlOverride=(0,_PlatformUtils.getManifest)().assetUrlOverride;if(assetUrlOverride){var _uri=_pathBrowserify.default.join(assetUrlOverride,hash);return{uri:resolveUri(_uri),hash:hash};}var fileScale=scale===1?'':\"@\"+scale+\"x\";var fileExtension=meta.type?\".\"+encodeURIComponent(meta.type):'';var suffix=\"/\"+encodeURIComponent(meta.name)+fileScale+fileExtension+\"?platform=\"+encodeURIComponent(_core.Platform.OS)+\"&hash=\"+encodeURIComponent(meta.hash);if(/^https?:\\/\\//.test(meta.httpServerLocation)){var _uri2=meta.httpServerLocation+suffix;return{uri:_uri2,hash:hash};}if((0,_PlatformUtils.getManifest)().developer){var baseUrl=new _urlParse.default((0,_PlatformUtils.getManifest)().bundleUrl);baseUrl.set('pathname',meta.httpServerLocation+suffix);return{uri:baseUrl.href,hash:hash};}return{uri:\"https://d1wp6m56sqw74a.cloudfront.net/~assets/\"+encodeURIComponent(hash),hash:hash};}function resolveUri(uri){if(!_PlatformUtils.manifestBaseUrl){return uri;}var _ref=new _urlParse.default(uri),protocol=_ref.protocol;if(protocol!==''){return uri;}var baseUrl=new _urlParse.default(_PlatformUtils.manifestBaseUrl);var resolvedPath=uri.startsWith('/')?uri:_pathBrowserify.default.join(baseUrl.pathname,uri);baseUrl.set('pathname',resolvedPath);return baseUrl.href;}","map":{"version":3,"sources":["../src/AssetSources.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\n\nimport { manifestBaseUrl, getManifest } from './PlatformUtils';\n\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}