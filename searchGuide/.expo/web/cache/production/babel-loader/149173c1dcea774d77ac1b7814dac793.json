{"ast":null,"code":"Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=memoize;function memoize(callback){var previous;var result;return function(){var hasChanged=false;for(var _len=arguments.length,dependencies=new Array(_len),_key=0;_key<_len;_key++){dependencies[_key]=arguments[_key];}if(previous){if(previous.length!==dependencies.length){hasChanged=true;}else{for(var i=0;i<previous.length;i++){if(previous[i]!==dependencies[i]){hasChanged=true;break;}}}}else{hasChanged=true;}previous=dependencies;if(hasChanged||result===undefined){result=callback.apply(void 0,dependencies);}return result;};}","map":{"version":3,"sources":["memoize.tsx"],"names":["dependencies","hasChanged","previous","i","result","callback"],"mappings":"iFAAe,QAAA,CAAA,OAAA,CAAA,QAAA,CAEb,CACA,GAAA,CAAA,QAAA,CACA,GAAA,CAAA,MAAA,CAEA,MAAO,WAAmC,CACxC,GAAIC,CAAAA,UAAU,CAAd,KAAA,CADwC,IAAA,GAAA,CAAA,IAAA,CAAA,SAAA,CAAA,MAAA,CAA/BD,YAA+B,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,EAAA,CAAA,CAA/BA,YAA+B,CAAA,IAAA,CAA/BA,CAA+B,SAAA,CAAA,IAAA,CAA/BA,CAGT,IAAA,QAAA,CAAc,CACZ,GAAIE,QAAQ,CAARA,MAAAA,GAAoBF,YAAY,CAApC,MAAA,CAA6C,CAC3CC,UAAU,CAAVA,IAAAA,CADF,CAAA,IAEO,CACL,IAAK,GAAIE,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGD,QAAQ,CAA5B,MAAA,CAAqCC,CAArC,EAAA,CAA0C,CACxC,GAAID,QAAQ,CAARA,CAAQ,CAARA,GAAgBF,YAAY,CAAhC,CAAgC,CAAhC,CAAqC,CACnCC,UAAU,CAAVA,IAAAA,CACA,MAEH,CACF,CACF,CAXD,CAAA,IAWO,CACLA,UAAU,CAAVA,IAAAA,CAGFC,CAAAA,QAAQ,CAARA,YAAAA,CAEA,GAAID,UAAU,EAAIG,MAAM,GAAxB,SAAA,CAAwC,CACtCA,MAAM,CAAGC,QAAQ,CAARA,KAAAA,CAAAA,IAAAA,EAAAA,CAATD,YAASC,CAATD,CAGF,OAAA,CAAA,MAAA,CAxBF,CAAA,CA0BD","sourcesContent":["export default function memoize<Result, Deps extends ReadonlyArray<any>>(\n  callback: (...deps: Deps) => Result\n) {\n  let previous: Deps | undefined;\n  let result: Result | undefined;\n\n  return (...dependencies: Deps): Result => {\n    let hasChanged = false;\n\n    if (previous) {\n      if (previous.length !== dependencies.length) {\n        hasChanged = true;\n      } else {\n        for (let i = 0; i < previous.length; i++) {\n          if (previous[i] !== dependencies[i]) {\n            hasChanged = true;\n            break;\n          }\n        }\n      }\n    } else {\n      hasChanged = true;\n    }\n\n    previous = dependencies;\n\n    if (hasChanged || result === undefined) {\n      result = callback(...dependencies);\n    }\n\n    return result;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}