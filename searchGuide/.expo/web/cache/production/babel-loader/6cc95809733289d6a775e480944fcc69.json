{"ast":null,"code":"var _interopRequireWildcard=require(\"@babel/runtime/helpers/interopRequireWildcard\");var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf3=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var React=_interopRequireWildcard(require(\"react\"));var _StyleSheet=_interopRequireDefault(require(\"react-native-web/dist/exports/StyleSheet\"));var _TextInput=_interopRequireDefault(require(\"react-native-web/dist/exports/TextInput\"));var _Keyboard=_interopRequireDefault(require(\"react-native-web/dist/exports/Keyboard\"));var _I18nManager=_interopRequireDefault(require(\"react-native-web/dist/exports/I18nManager\"));var _reactNativeGestureHandler=require(\"react-native-gesture-handler\");var _reactNativeReanimated=_interopRequireWildcard(require(\"react-native-reanimated\"));var _memoize=_interopRequireDefault(require(\"./memoize\"));var _jsxFileName=\"/Users/satya/Workspace/Projects/react-native-tab-view/src/Pager.tsx\";var Clock=_reactNativeReanimated.default.Clock,Value=_reactNativeReanimated.default.Value,onChange=_reactNativeReanimated.default.onChange,and=_reactNativeReanimated.default.and,abs=_reactNativeReanimated.default.abs,add=_reactNativeReanimated.default.add,block=_reactNativeReanimated.default.block,call=_reactNativeReanimated.default.call,ceil=_reactNativeReanimated.default.ceil,clockRunning=_reactNativeReanimated.default.clockRunning,cond=_reactNativeReanimated.default.cond,divide=_reactNativeReanimated.default.divide,eq=_reactNativeReanimated.default.eq,event=_reactNativeReanimated.default.event,floor=_reactNativeReanimated.default.floor,greaterThan=_reactNativeReanimated.default.greaterThan,lessThan=_reactNativeReanimated.default.lessThan,max=_reactNativeReanimated.default.max,min=_reactNativeReanimated.default.min,multiply=_reactNativeReanimated.default.multiply,neq=_reactNativeReanimated.default.neq,not=_reactNativeReanimated.default.not,round=_reactNativeReanimated.default.round,set=_reactNativeReanimated.default.set,spring=_reactNativeReanimated.default.spring,startClock=_reactNativeReanimated.default.startClock,stopClock=_reactNativeReanimated.default.stopClock,sub=_reactNativeReanimated.default.sub,timing=_reactNativeReanimated.default.timing;var TRUE=1;var FALSE=0;var NOOP=0;var UNSET=-1;var DIRECTION_LEFT=1;var DIRECTION_RIGHT=-1;var SWIPE_DISTANCE_MINIMUM=20;var SWIPE_VELOCITY_IMPACT=0.2;var SPRING_CONFIG={stiffness:1000,damping:500,mass:3,overshootClamping:true,restDisplacementThreshold:0.01,restSpeedThreshold:0.01};var SPRING_VELOCITY_SCALE=1;var TIMING_CONFIG={duration:200,easing:_reactNativeReanimated.Easing.out(_reactNativeReanimated.Easing.cubic)};var Pager=function(_React$Component){(0,_inherits2.default)(Pager,_React$Component);function Pager(){var _getPrototypeOf2;var _this;(0,_classCallCheck2.default)(this,Pager);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=(0,_possibleConstructorReturn2.default)(this,(_getPrototypeOf2=(0,_getPrototypeOf3.default)(Pager)).call.apply(_getPrototypeOf2,[this].concat(args)));_this.clock=new Clock();_this.velocityX=new Value(0);_this.gestureX=new Value(0);_this.gestureState=new Value(_reactNativeGestureHandler.State.UNDETERMINED);_this.offsetX=new Value(0);_this.progress=new Value(_this.props.navigationState.index*_this.props.layout.width*DIRECTION_RIGHT);_this.index=new Value(_this.props.navigationState.index);_this.nextIndex=new Value(UNSET);_this.lastEnteredIndex=new Value(_this.props.navigationState.index);_this.isSwiping=new Value(FALSE);_this.isSwipeGesture=new Value(FALSE);_this.indexAtSwipeEnd=new Value(_this.props.navigationState.index);_this.routesLength=new Value(_this.props.navigationState.routes.length);_this.layoutWidth=new Value(_this.props.layout.width);_this.swipeVelocityImpact=new Value(_this.props.swipeVelocityImpact!==undefined?_this.props.swipeVelocityImpact:SWIPE_VELOCITY_IMPACT);_this.springVelocityScale=new Value(_this.props.springVelocityScale!==undefined?_this.props.springVelocityScale:SPRING_VELOCITY_SCALE);_this.position=cond(_this.layoutWidth,divide(multiply(_this.progress,-1),_this.layoutWidth),_this.index);_this.springConfig={damping:new Value(_this.props.springConfig.damping!==undefined?_this.props.springConfig.damping:SPRING_CONFIG.damping),mass:new Value(_this.props.springConfig.mass!==undefined?_this.props.springConfig.mass:SPRING_CONFIG.mass),stiffness:new Value(_this.props.springConfig.stiffness!==undefined?_this.props.springConfig.stiffness:SPRING_CONFIG.stiffness),restSpeedThreshold:new Value(_this.props.springConfig.restSpeedThreshold!==undefined?_this.props.springConfig.restSpeedThreshold:SPRING_CONFIG.restSpeedThreshold),restDisplacementThreshold:new Value(_this.props.springConfig.restDisplacementThreshold!==undefined?_this.props.springConfig.restDisplacementThreshold:SPRING_CONFIG.restDisplacementThreshold)};_this.timingConfig={duration:new Value(_this.props.timingConfig.duration!==undefined?_this.props.timingConfig.duration:TIMING_CONFIG.duration)};_this.initialVelocityForSpring=new Value(0);_this.currentIndexValue=_this.props.navigationState.index;_this.pendingIndexValue=undefined;_this.previouslyFocusedTextInput=null;_this.enterListeners=[];_this.jumpToIndex=function(index){_this.isSwipeGesture.setValue(FALSE);_this.nextIndex.setValue(index);};_this.jumpTo=function(key){var _this$props=_this.props,navigationState=_this$props.navigationState,keyboardDismissMode=_this$props.keyboardDismissMode,onIndexChange=_this$props.onIndexChange;var index=navigationState.routes.findIndex(function(route){return route.key===key;});if(navigationState.index===index){_this.jumpToIndex(index);}else{onIndexChange(index);if(keyboardDismissMode==='auto'){_Keyboard.default.dismiss();}}};_this.addListener=function(type,listener){switch(type){case'enter':_this.enterListeners.push(listener);break;}};_this.removeListener=function(type,listener){switch(type){case'enter':{var _index=_this.enterListeners.indexOf(listener);if(_index>-1){_this.enterListeners.splice(_index,1);}break;}}};_this.handleEnteredIndexChange=function(_ref){var _ref2=(0,_slicedToArray2.default)(_ref,1),value=_ref2[0];var index=Math.max(0,Math.min(value,_this.props.navigationState.routes.length-1));_this.enterListeners.forEach(function(listener){return listener(index);});};_this.transitionTo=function(index){var toValue=new Value(0);var frameTime=new Value(0);var state={position:_this.progress,time:new Value(0),finished:new Value(FALSE)};return block([cond(clockRunning(_this.clock),NOOP,[set(toValue,multiply(index,_this.layoutWidth,DIRECTION_RIGHT)),set(frameTime,0),set(state.time,0),set(state.finished,FALSE),set(_this.index,index)]),cond(_this.isSwipeGesture,[cond(not(clockRunning(_this.clock)),_I18nManager.default.isRTL?set(_this.initialVelocityForSpring,multiply(-1,_this.velocityX,_this.springVelocityScale)):set(_this.initialVelocityForSpring,multiply(_this.velocityX,_this.springVelocityScale))),spring(_this.clock,(0,_objectSpread2.default)({},state,{velocity:_this.initialVelocityForSpring}),(0,_objectSpread2.default)({},SPRING_CONFIG,_this.springConfig,{toValue:toValue}))],timing(_this.clock,(0,_objectSpread2.default)({},state,{frameTime:frameTime}),(0,_objectSpread2.default)({},TIMING_CONFIG,_this.timingConfig,{toValue:toValue}))),cond(not(clockRunning(_this.clock)),startClock(_this.clock)),cond(state.finished,[set(_this.isSwipeGesture,FALSE),set(_this.gestureX,0),set(_this.velocityX,0),stopClock(_this.clock)])]);};_this.handleGestureEvent=event([{nativeEvent:{translationX:_this.gestureX,velocityX:_this.velocityX,state:_this.gestureState}}]);_this.extrapolatedPosition=add(_this.gestureX,multiply(_this.velocityX,_this.swipeVelocityImpact));_this.translateX=block([onChange(_this.index,call([_this.index],function(_ref3){var _ref4=(0,_slicedToArray2.default)(_ref3,1),value=_ref4[0];_this.currentIndexValue=value;if(value!==_this.props.navigationState.index){_this.props.onIndexChange(value);_this.pendingIndexValue=value;_this.forceUpdate();}})),onChange(_this.position,cond(_I18nManager.default.isRTL?lessThan(_this.gestureX,0):greaterThan(_this.gestureX,0),cond(neq(floor(_this.position),_this.lastEnteredIndex),[set(_this.lastEnteredIndex,floor(_this.position)),call([floor(_this.position)],_this.handleEnteredIndexChange)]),cond(neq(ceil(_this.position),_this.lastEnteredIndex),[set(_this.lastEnteredIndex,ceil(_this.position)),call([ceil(_this.position)],_this.handleEnteredIndexChange)]))),onChange(_this.isSwiping,call([_this.isSwiping,_this.indexAtSwipeEnd,_this.index],function(_ref5){var _ref6=(0,_slicedToArray2.default)(_ref5,3),isSwiping=_ref6[0],indexAtSwipeEnd=_ref6[1],currentIndex=_ref6[2];var _this$props2=_this.props,keyboardDismissMode=_this$props2.keyboardDismissMode,onSwipeStart=_this$props2.onSwipeStart,onSwipeEnd=_this$props2.onSwipeEnd;if(isSwiping===TRUE){onSwipeStart&&onSwipeStart();if(keyboardDismissMode==='auto'){var input=_TextInput.default.State.currentlyFocusedField();_TextInput.default.State.blurTextInput(input);_this.previouslyFocusedTextInput=input;}else if(keyboardDismissMode==='on-drag'){_Keyboard.default.dismiss();}}else{onSwipeEnd&&onSwipeEnd();if(keyboardDismissMode==='auto'){if(indexAtSwipeEnd===currentIndex){var _input=_this.previouslyFocusedTextInput;if(_input){_TextInput.default.State.focusTextInput(_input);}}_this.previouslyFocusedTextInput=null;}}})),onChange(_this.nextIndex,cond(neq(_this.nextIndex,UNSET),[cond(clockRunning(_this.clock),stopClock(_this.clock)),set(_this.gestureX,0),set(_this.index,_this.nextIndex),set(_this.nextIndex,UNSET)])),cond(eq(_this.gestureState,_reactNativeGestureHandler.State.ACTIVE),[cond(_this.isSwiping,NOOP,[set(_this.isSwiping,TRUE),set(_this.isSwipeGesture,TRUE),set(_this.offsetX,_this.progress)]),set(_this.progress,_I18nManager.default.isRTL?sub(_this.offsetX,_this.gestureX):add(_this.offsetX,_this.gestureX)),stopClock(_this.clock)],[set(_this.isSwiping,FALSE),set(_this.indexAtSwipeEnd,_this.index),_this.transitionTo(cond(and(greaterThan(abs(_this.gestureX),SWIPE_DISTANCE_MINIMUM),greaterThan(abs(_this.extrapolatedPosition),divide(_this.layoutWidth,2))),round(min(max(0,sub(_this.index,cond(greaterThan(_this.extrapolatedPosition,0),_I18nManager.default.isRTL?DIRECTION_RIGHT:DIRECTION_LEFT,_I18nManager.default.isRTL?DIRECTION_LEFT:DIRECTION_RIGHT))),sub(_this.routesLength,1))),_this.index))]),_this.progress]);_this.getTranslateX=(0,_memoize.default)(function(layoutWidth,routesLength,translateX){return multiply(min(max(multiply(layoutWidth,sub(routesLength,1),DIRECTION_RIGHT),translateX),0),_I18nManager.default.isRTL?-1:1);});return _this;}(0,_createClass2.default)(Pager,[{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps){var _this$props3=this.props,navigationState=_this$props3.navigationState,layout=_this$props3.layout,swipeVelocityImpact=_this$props3.swipeVelocityImpact,springVelocityScale=_this$props3.springVelocityScale,springConfig=_this$props3.springConfig,timingConfig=_this$props3.timingConfig;var index=navigationState.index,routes=navigationState.routes;if(index!==prevProps.navigationState.index&&index!==this.currentIndexValue||typeof this.pendingIndexValue==='number'&&index!==this.pendingIndexValue){this.jumpToIndex(index);}this.pendingIndexValue=undefined;if(prevProps.navigationState.routes.length!==routes.length){this.routesLength.setValue(routes.length);}if(prevProps.layout.width!==layout.width){this.progress.setValue(-index*layout.width);this.layoutWidth.setValue(layout.width);}if(prevProps.swipeVelocityImpact!==swipeVelocityImpact){this.swipeVelocityImpact.setValue(swipeVelocityImpact!==undefined?swipeVelocityImpact:SWIPE_VELOCITY_IMPACT);}if(prevProps.springVelocityScale!==springVelocityScale){this.springVelocityScale.setValue(springVelocityScale!==undefined?springVelocityScale:SPRING_VELOCITY_SCALE);}if(prevProps.springConfig!==springConfig){this.springConfig.damping.setValue(springConfig.damping!==undefined?springConfig.damping:SPRING_CONFIG.damping);this.springConfig.mass.setValue(springConfig.mass!==undefined?springConfig.mass:SPRING_CONFIG.mass);this.springConfig.stiffness.setValue(springConfig.stiffness!==undefined?springConfig.stiffness:SPRING_CONFIG.stiffness);this.springConfig.restSpeedThreshold.setValue(springConfig.restSpeedThreshold!==undefined?springConfig.restSpeedThreshold:SPRING_CONFIG.restSpeedThreshold);this.springConfig.restDisplacementThreshold.setValue(springConfig.restDisplacementThreshold!==undefined?springConfig.restDisplacementThreshold:SPRING_CONFIG.restDisplacementThreshold);}if(prevProps.timingConfig!==timingConfig){this.timingConfig.duration.setValue(timingConfig.duration!==undefined?timingConfig.duration:TIMING_CONFIG.duration);}}},{key:\"render\",value:function render(){var _this2=this;var _this$props4=this.props,layout=_this$props4.layout,navigationState=_this$props4.navigationState,swipeEnabled=_this$props4.swipeEnabled,children=_this$props4.children,removeClippedSubviews=_this$props4.removeClippedSubviews,gestureHandlerProps=_this$props4.gestureHandlerProps;var translateX=this.getTranslateX(this.layoutWidth,this.routesLength,this.translateX);return children({position:this.position,addListener:this.addListener,removeListener:this.removeListener,jumpTo:this.jumpTo,render:function render(children){return React.createElement(_reactNativeGestureHandler.PanGestureHandler,(0,_extends2.default)({enabled:layout.width!==0&&swipeEnabled,onGestureEvent:_this2.handleGestureEvent,onHandlerStateChange:_this2.handleGestureEvent,activeOffsetX:[-SWIPE_DISTANCE_MINIMUM,SWIPE_DISTANCE_MINIMUM],failOffsetY:[-SWIPE_DISTANCE_MINIMUM,SWIPE_DISTANCE_MINIMUM]},gestureHandlerProps,{__source:{fileName:_jsxFileName,lineNumber:659}}),React.createElement(_reactNativeReanimated.default.View,{removeClippedSubviews:removeClippedSubviews,style:[styles.container,layout.width?{width:layout.width*navigationState.routes.length,transform:[{translateX:translateX}]}:null],__source:{fileName:_jsxFileName,lineNumber:667}},children));}});}}]);return Pager;}(React.Component);exports.default=Pager;Pager.defaultProps={swipeVelocityImpact:SWIPE_VELOCITY_IMPACT,springVelocityScale:SPRING_VELOCITY_SCALE};var styles=_StyleSheet.default.create({container:{flex:1,flexDirection:'row'}});","map":{"version":3,"sources":["Pager.tsx"],"names":["Clock","Value","onChange","and","abs","add","block","call","ceil","clockRunning","cond","divide","eq","event","floor","greaterThan","lessThan","max","min","multiply","neq","not","round","set","spring","startClock","stopClock","sub","timing","Animated","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_VELOCITY_IMPACT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","SPRING_VELOCITY_SCALE","TIMING_CONFIG","duration","easing","Easing","Pager","React","Component","defaultProps","swipeVelocityImpact","springVelocityScale","prevProps","navigationState","layout","springConfig","timingConfig","index","routes","clock","velocityX","gestureX","gestureState","State","offsetX","progress","nextIndex","lastEnteredIndex","isSwiping","isSwipeGesture","indexAtSwipeEnd","routesLength","layoutWidth","position","initialVelocityForSpring","currentIndexValue","pendingIndexValue","undefined","previouslyFocusedTextInput","enterListeners","jumpToIndex","jumpTo","keyboardDismissMode","onIndexChange","route","Keyboard","addListener","removeListener","handleEnteredIndexChange","value","Math","listener","transitionTo","toValue","frameTime","state","time","finished","I18nManager","velocity","handleGestureEvent","nativeEvent","translationX","extrapolatedPosition","translateX","currentIndex","onSwipeStart","onSwipeEnd","input","TextInput","getTranslateX","memoize","swipeEnabled","children","removeClippedSubviews","gestureHandlerProps","render","styles","width","transform","StyleSheet","container","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, TextInput, Keyboard, I18nManager } from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { Easing } from 'react-native-reanimated';\nimport memoize from './memoize';\n\nimport {\n  Layout,\n  NavigationState,\n  Route,\n  Listener,\n  PagerCommonProps,\n  EventEmitterProps,\n} from './types';\n\ntype Binary = 0 | 1;\n\ntype Props<T extends Route> = PagerCommonProps & {\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  layout: Layout;\n  // Clip unfocused views to improve memory usage\n  // Don't enable this on iOS where this is buggy and views don't re-appear\n  removeClippedSubviews?: boolean;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.Node<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactNode;\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\n};\n\nconst {\n  Clock,\n  Value,\n  onChange,\n  and,\n  abs,\n  add,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing,\n} = Animated;\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\n\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\n\nconst SWIPE_DISTANCE_MINIMUM = 20;\n\nconst SWIPE_VELOCITY_IMPACT = 0.2;\n\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nconst SPRING_VELOCITY_SCALE = 1;\n\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic),\n};\n\nexport default class Pager<T extends Route> extends React.Component<Props<T>> {\n  static defaultProps = {\n    swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\n    springVelocityScale: SPRING_VELOCITY_SCALE,\n  };\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const {\n      navigationState,\n      layout,\n      swipeVelocityImpact,\n      springVelocityScale,\n      springConfig,\n      timingConfig,\n    } = this.props;\n    const { index, routes } = navigationState;\n\n    if (\n      // Check for index in state to avoid unintended transition if component updates during swipe\n      (index !== prevProps.navigationState.index &&\n        index !== this.currentIndexValue) ||\n      // Check if the user updated the index correctly after an update\n      (typeof this.pendingIndexValue === 'number' &&\n        index !== this.pendingIndexValue)\n    ) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    }\n\n    // Reset the pending index\n    this.pendingIndexValue = undefined;\n\n    // Update our mappings of animated nodes when props change\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\n      this.swipeVelocityImpact.setValue(\n        swipeVelocityImpact !== undefined\n          ? swipeVelocityImpact\n          : SWIPE_VELOCITY_IMPACT\n      );\n    }\n\n    if (prevProps.springVelocityScale !== springVelocityScale) {\n      this.springVelocityScale.setValue(\n        springVelocityScale !== undefined\n          ? springVelocityScale\n          : SPRING_VELOCITY_SCALE\n      );\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(\n        springConfig.damping !== undefined\n          ? springConfig.damping\n          : SPRING_CONFIG.damping\n      );\n\n      this.springConfig.mass.setValue(\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\n      );\n\n      this.springConfig.stiffness.setValue(\n        springConfig.stiffness !== undefined\n          ? springConfig.stiffness\n          : SPRING_CONFIG.stiffness\n      );\n\n      this.springConfig.restSpeedThreshold.setValue(\n        springConfig.restSpeedThreshold !== undefined\n          ? springConfig.restSpeedThreshold\n          : SPRING_CONFIG.restSpeedThreshold\n      );\n\n      this.springConfig.restDisplacementThreshold.setValue(\n        springConfig.restDisplacementThreshold !== undefined\n          ? springConfig.restDisplacementThreshold\n          : SPRING_CONFIG.restDisplacementThreshold\n      );\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(\n        timingConfig.duration !== undefined\n          ? timingConfig.duration\n          : TIMING_CONFIG.duration\n      );\n    }\n  }\n\n  // Clock used for tab transition animations\n  private clock = new Clock();\n\n  // Current state of the gesture\n  private velocityX = new Value(0);\n  private gestureX = new Value(0);\n  private gestureState = new Value(State.UNDETERMINED);\n  private offsetX = new Value(0);\n\n  // Current progress of the page (translateX value)\n  private progress = new Value(\n    // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\n  );\n\n  // Initial index of the tabs\n  private index = new Value(this.props.navigationState.index);\n\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\n\n  // Scene that was last entered\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\n\n  // Whether the user is currently dragging the screen\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\n\n  // Whether the update was due to swipe gesture\n  // This controls whether the transition will use a spring or timing animation\n  // Remember to set it before transition needs to occur\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\n\n  // Track the index value when a swipe gesture has ended\n  // This lets us know if a gesture end triggered a tab switch or not\n  private indexAtSwipeEnd: Animated.Value<number> = new Value(\n    this.props.navigationState.index\n  );\n\n  // Mappings to some prop values\n  // We use them in animation calculations, so we need live animated nodes\n  private routesLength = new Value(this.props.navigationState.routes.length);\n  private layoutWidth = new Value(this.props.layout.width);\n\n  // Determines how relevant is a velocity while calculating next position while swiping\n  private swipeVelocityImpact = new Value(\n    this.props.swipeVelocityImpact !== undefined\n      ? this.props.swipeVelocityImpact\n      : SWIPE_VELOCITY_IMPACT\n  );\n\n  private springVelocityScale = new Value(\n    this.props.springVelocityScale !== undefined\n      ? this.props.springVelocityScale\n      : SPRING_VELOCITY_SCALE\n  );\n\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\n  // It is calculated based on the translate value and layout width\n  // If we don't have the layout yet, we should return the current index\n  private position = cond(\n    this.layoutWidth,\n    divide(multiply(this.progress, -1), this.layoutWidth),\n    this.index\n  );\n\n  // Animation configuration\n  private springConfig = {\n    damping: new Value(\n      this.props.springConfig.damping !== undefined\n        ? this.props.springConfig.damping\n        : SPRING_CONFIG.damping\n    ),\n    mass: new Value(\n      this.props.springConfig.mass !== undefined\n        ? this.props.springConfig.mass\n        : SPRING_CONFIG.mass\n    ),\n    stiffness: new Value(\n      this.props.springConfig.stiffness !== undefined\n        ? this.props.springConfig.stiffness\n        : SPRING_CONFIG.stiffness\n    ),\n    restSpeedThreshold: new Value(\n      this.props.springConfig.restSpeedThreshold !== undefined\n        ? this.props.springConfig.restSpeedThreshold\n        : SPRING_CONFIG.restSpeedThreshold\n    ),\n    restDisplacementThreshold: new Value(\n      this.props.springConfig.restDisplacementThreshold !== undefined\n        ? this.props.springConfig.restDisplacementThreshold\n        : SPRING_CONFIG.restDisplacementThreshold\n    ),\n  };\n\n  private timingConfig = {\n    duration: new Value(\n      this.props.timingConfig.duration !== undefined\n        ? this.props.timingConfig.duration\n        : TIMING_CONFIG.duration\n    ),\n  };\n\n  // The reason for using this value instead of simply passing `this._velocity`\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\n  // Also, it's not possible to pass multiplied value there, because\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\n  // Animated.Value. So this value is being updated on each start of spring animation.\n  private initialVelocityForSpring = new Value(0);\n\n  // The current index change caused by the pager's animation\n  // The pager is used as a controlled component\n  // We need to keep track of the index to determine when to trigger animation\n  // The state will change at various points, we should only respond when we are out of sync\n  // This will ensure smoother animation and avoid weird glitches\n  private currentIndexValue = this.props.navigationState.index;\n\n  // The pending index value as result of state update caused by swipe gesture\n  // We need to set it when state changes from inside this component\n  // It also needs to be reset right after componentDidUpdate fires\n  private pendingIndexValue: number | undefined = undefined;\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n\n  // Listeners for the entered screen\n  private enterListeners: Listener[] = [];\n\n  private jumpToIndex = (index: number) => {\n    // If the index changed, we need to trigger a tab switch\n    this.isSwipeGesture.setValue(FALSE);\n    this.nextIndex.setValue(index);\n  };\n\n  private jumpTo = (key: string) => {\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(route => route.key === key);\n\n    // A tab switch might occur when we're in the middle of a transition\n    // In that case, the index might be same as before\n    // So we conditionally make the pager to update the position\n    if (navigationState.index === index) {\n      this.jumpToIndex(index);\n    } else {\n      onIndexChange(index);\n\n      // When the index changes, the focused input will no longer be in current tab\n      // So we should dismiss the keyboard\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\n    const index = Math.max(\n      0,\n      Math.min(value, this.props.navigationState.routes.length - 1)\n    );\n\n    this.enterListeners.forEach(listener => listener(index));\n  };\n\n  private transitionTo = (index: Animated.Node<number>) => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n\n    const state = {\n      position: this.progress,\n      time: new Value(0),\n      finished: new Value(FALSE),\n    };\n\n    return block([\n      cond(clockRunning(this.clock), NOOP, [\n        // Animation wasn't running before\n        // Set the initial values and start the clock\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\n        set(frameTime, 0),\n        set(state.time, 0),\n        set(state.finished, FALSE),\n        set(this.index, index),\n      ]),\n      cond(\n        this.isSwipeGesture,\n        // Animate the values with a spring for swipe\n        [\n          cond(\n            not(clockRunning(this.clock)),\n            I18nManager.isRTL\n              ? set(\n                  this.initialVelocityForSpring,\n                  multiply(-1, this.velocityX, this.springVelocityScale)\n                )\n              : set(\n                  this.initialVelocityForSpring,\n                  multiply(this.velocityX, this.springVelocityScale)\n                )\n          ),\n          spring(\n            this.clock,\n            { ...state, velocity: this.initialVelocityForSpring },\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\n          ),\n        ],\n        // Otherwise use a timing animation for faster switching\n        timing(\n          this.clock,\n          { ...state, frameTime },\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\n        )\n      ),\n      cond(not(clockRunning(this.clock)), startClock(this.clock)),\n      cond(state.finished, [\n        // Reset values\n        set(this.isSwipeGesture, FALSE),\n        set(this.gestureX, 0),\n        set(this.velocityX, 0),\n        // When the animation finishes, stop the clock\n        stopClock(this.clock),\n      ]),\n    ]);\n  };\n\n  private handleGestureEvent = event([\n    {\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private extrapolatedPosition = add(\n    this.gestureX,\n    multiply(this.velocityX, this.swipeVelocityImpact)\n  );\n\n  private translateX = block([\n    onChange(\n      this.index,\n      call([this.index], ([value]) => {\n        this.currentIndexValue = value;\n\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n        if (value !== this.props.navigationState.index) {\n          // If the index changed, and previous animation has finished, update state\n          this.props.onIndexChange(value);\n\n          this.pendingIndexValue = value;\n\n          // Force componentDidUpdate to fire, whether user does a setState or not\n          // This allows us to detect when the user drops the update and revert back\n          // It's necessary to make sure that the state stays in sync\n          this.forceUpdate();\n        }\n      })\n    ),\n    onChange(\n      this.position,\n      // Listen to updates in the position to detect when we enter a screen\n      // This is useful for things such as lazy loading when index change will fire too late\n      cond(\n        I18nManager.isRTL\n          ? lessThan(this.gestureX, 0)\n          : greaterThan(this.gestureX, 0),\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, floor(this.position)),\n          call([floor(this.position)], this.handleEnteredIndexChange),\n        ]),\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, ceil(this.position)),\n          call([ceil(this.position)], this.handleEnteredIndexChange),\n        ])\n      )\n    ),\n    onChange(\n      this.isSwiping,\n      // Listen to updates for this value only when it changes\n      // Without `onChange`, this will fire even if the value didn't change\n      // We don't want to call the listeners if the value didn't change\n      call(\n        [this.isSwiping, this.indexAtSwipeEnd, this.index],\n        ([isSwiping, indexAtSwipeEnd, currentIndex]: readonly number[]) => {\n          const { keyboardDismissMode, onSwipeStart, onSwipeEnd } = this.props;\n\n          if (isSwiping === TRUE) {\n            onSwipeStart && onSwipeStart();\n\n            if (keyboardDismissMode === 'auto') {\n              const input = TextInput.State.currentlyFocusedField();\n\n              // When a gesture begins, blur the currently focused input\n              TextInput.State.blurTextInput(input);\n\n              // Store the id of this input so we can refocus it if gesture was cancelled\n              this.previouslyFocusedTextInput = input;\n            } else if (keyboardDismissMode === 'on-drag') {\n              Keyboard.dismiss();\n            }\n          } else {\n            onSwipeEnd && onSwipeEnd();\n\n            if (keyboardDismissMode === 'auto') {\n              if (indexAtSwipeEnd === currentIndex) {\n                // The index didn't change, we should restore the focus of text input\n                const input = this.previouslyFocusedTextInput;\n\n                if (input) {\n                  TextInput.State.focusTextInput(input);\n                }\n              }\n\n              this.previouslyFocusedTextInput = null;\n            }\n          }\n        }\n      )\n    ),\n    onChange(\n      this.nextIndex,\n      cond(neq(this.nextIndex, UNSET), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), stopClock(this.clock)),\n        set(this.gestureX, 0),\n        // Update the index to trigger the transition\n        set(this.index, this.nextIndex),\n        set(this.nextIndex, UNSET),\n      ])\n    ),\n    cond(\n      eq(this.gestureState, State.ACTIVE),\n      [\n        cond(this.isSwiping, NOOP, [\n          // We weren't dragging before, set it to true\n          set(this.isSwiping, TRUE),\n          set(this.isSwipeGesture, TRUE),\n          // Also update the drag offset to the last progress\n          set(this.offsetX, this.progress),\n        ]),\n        // Update progress with previous offset + gesture distance\n        set(\n          this.progress,\n          I18nManager.isRTL\n            ? sub(this.offsetX, this.gestureX)\n            : add(this.offsetX, this.gestureX)\n        ),\n        // Stop animations while we're dragging\n        stopClock(this.clock),\n      ],\n      [\n        set(this.isSwiping, FALSE),\n        set(this.indexAtSwipeEnd, this.index),\n        this.transitionTo(\n          cond(\n            and(\n              // We should consider velocity and gesture distance only when a swipe ends\n              // The gestureX value will be non-zero when swipe has happened\n              // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\n              // For other factors such as state update, the velocity and gesture distance don't matter\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\n              greaterThan(\n                abs(this.extrapolatedPosition),\n                divide(this.layoutWidth, 2)\n              )\n            ),\n            // For swipe gesture, to calculate the index, determine direction and add to index\n            // When the user swipes towards the left, we transition to the next tab\n            // When the user swipes towards the right, we transition to the previous tab\n            round(\n              min(\n                max(\n                  0,\n                  sub(\n                    this.index,\n                    cond(\n                      greaterThan(this.extrapolatedPosition, 0),\n                      I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                      I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                    )\n                  )\n                ),\n                sub(this.routesLength, 1)\n              )\n            ),\n            // Index didn't change/changed due to state update\n            this.index\n          )\n        ),\n      ]\n    ),\n    this.progress,\n  ]);\n\n  private getTranslateX = memoize(\n    (\n      layoutWidth: Animated.Node<number>,\n      routesLength: Animated.Node<number>,\n      translateX: Animated.Node<number>\n    ) =>\n      multiply(\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n        min(\n          max(\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\n            translateX\n          ),\n          0\n        ),\n        I18nManager.isRTL ? -1 : 1\n      )\n  );\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps,\n    } = this.props;\n\n    const translateX = this.getTranslateX(\n      this.layoutWidth,\n      this.routesLength,\n      this.translateX\n    );\n\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => (\n        <PanGestureHandler\n          enabled={layout.width !== 0 && swipeEnabled}\n          onGestureEvent={this.handleGestureEvent}\n          onHandlerStateChange={this.handleGestureEvent}\n          activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          {...gestureHandlerProps}\n        >\n          <Animated.View\n            removeClippedSubviews={removeClippedSubviews}\n            style={[\n              styles.container,\n              layout.width\n                ? {\n                    width: layout.width * navigationState.routes.length,\n                    transform: [{ translateX }] as any,\n                  }\n                : null,\n            ]}\n          >\n            {children}\n          </Animated.View>\n        </PanGestureHandler>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n"]},"metadata":{},"sourceType":"script"}