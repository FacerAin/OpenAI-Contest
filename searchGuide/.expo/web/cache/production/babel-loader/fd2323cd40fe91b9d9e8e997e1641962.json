{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _react=_interopRequireDefault(require(\"react\"));var _AnimatedAlways=require(\"./AnimatedAlways\");var _AnimatedNode=_interopRequireDefault(require(\"./AnimatedNode\"));var Code=function(_React$Component){(0,_inherits2.default)(Code,_React$Component);function Code(){(0,_classCallCheck2.default)(this,Code);return(0,_possibleConstructorReturn2.default)(this,(0,_getPrototypeOf2.default)(Code).apply(this,arguments));}(0,_createClass2.default)(Code,[{key:\"componentDidMount\",value:function componentDidMount(){var _this$props=this.props,children=_this$props.children,exec=_this$props.exec;var nodeChildren=Code.resolveNode(children);var nodeExec=Code.resolveNode(exec);var cantResolveNode=nodeChildren===null&&nodeExec===null;if(cantResolveNode){var error=nodeChildren===null?\"Got \\\"\"+typeof children+\"\\\" type passed to children\":\"Got \\\"\"+typeof exec+\"\\\" type passed to exec\";throw new Error(\"<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. \"+error);}this.always=(0,_AnimatedAlways.createAnimatedAlways)(nodeExec||nodeChildren);this.always.__attach();}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){this.always.__detach();}},{key:\"render\",value:function render(){return null;}}]);return Code;}(_react.default.Component);Code.resolveNode=function(maybeNode){if(typeof maybeNode==='function'){return Code.resolveNode(maybeNode());}if(maybeNode instanceof _AnimatedNode.default){return maybeNode;}return null;};var _default=Code;exports.default=_default;","map":{"version":3,"sources":["C:/Users/bluej/Desktop/2_2/searchGuide/searchGuide/node_modules/react-native-reanimated/src/core/AnimatedCode.js"],"names":["Code","props","children","exec","nodeChildren","resolveNode","nodeExec","cantResolveNode","error","Error","always","__attach","__detach","React","Component","maybeNode","AnimatedNode"],"mappings":"6nBAAA,oDACA,gDACA,oE,GAEMA,CAAAA,I,2UAagB,iBACS,KAAKC,KADd,CACVC,QADU,aACVA,QADU,CACAC,IADA,aACAA,IADA,CAElB,GAAMC,CAAAA,YAAY,CAAGJ,IAAI,CAACK,WAAL,CAAiBH,QAAjB,CAArB,CACA,GAAMI,CAAAA,QAAQ,CAAGN,IAAI,CAACK,WAAL,CAAiBF,IAAjB,CAAjB,CAEA,GAAMI,CAAAA,eAAe,CAAGH,YAAY,GAAK,IAAjB,EAAyBE,QAAQ,GAAK,IAA9D,CAEA,GAAIC,eAAJ,CAAqB,CACnB,GAAMC,CAAAA,KAAK,CACTJ,YAAY,GAAK,IAAjB,UACY,MAAOF,CAAAA,QADnB,uCAEY,MAAOC,CAAAA,IAFnB,yBADF,CAKA,KAAM,IAAIM,CAAAA,KAAJ,2HACsHD,KADtH,CAAN,CAGD,CAED,KAAKE,MAAL,CAAc,yCAAqBJ,QAAQ,EAAIF,YAAjC,CAAd,CACA,KAAKM,MAAL,CAAYC,QAAZ,GACD,C,mEAEsB,CACrB,KAAKD,MAAL,CAAYE,QAAZ,GACD,C,uCAEQ,CACP,MAAO,KAAP,CACD,C,kBAzCgBC,eAAMC,S,EAAnBd,I,CACGK,W,CAAc,SAAAU,SAAS,CAAI,CAChC,GAAI,MAAOA,CAAAA,SAAP,GAAqB,UAAzB,CAAqC,CACnC,MAAOf,CAAAA,IAAI,CAACK,WAAL,CAAiBU,SAAS,EAA1B,CAAP,CACD,CAED,GAAIA,SAAS,WAAYC,sBAAzB,CAAuC,CACrC,MAAOD,CAAAA,SAAP,CACD,CAED,MAAO,KAAP,CACD,C,cAgCYf,I","sourcesContent":["import React from 'react';\nimport { createAnimatedAlways } from './AnimatedAlways';\nimport AnimatedNode from './AnimatedNode';\n\nclass Code extends React.Component {\n  static resolveNode = maybeNode => {\n    if (typeof maybeNode === 'function') {\n      return Code.resolveNode(maybeNode());\n    }\n\n    if (maybeNode instanceof AnimatedNode) {\n      return maybeNode;\n    }\n\n    return null;\n  };\n\n  componentDidMount() {\n    const { children, exec } = this.props;\n    const nodeChildren = Code.resolveNode(children);\n    const nodeExec = Code.resolveNode(exec);\n\n    const cantResolveNode = nodeChildren === null && nodeExec === null;\n\n    if (cantResolveNode) {\n      const error =\n        nodeChildren === null\n          ? `Got \"${typeof children}\" type passed to children`\n          : `Got \"${typeof exec}\" type passed to exec`;\n\n      throw new Error(\n        `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`\n      );\n    }\n\n    this.always = createAnimatedAlways(nodeExec || nodeChildren);\n    this.always.__attach();\n  }\n\n  componentWillUnmount() {\n    this.always.__detach();\n  }\n\n  render() {\n    return null;\n  }\n}\nexport default Code;\n"]},"metadata":{},"sourceType":"script"}