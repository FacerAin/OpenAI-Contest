{"ast":null,"code":"var _interopRequireWildcard=require(\"@babel/runtime/helpers/interopRequireWildcard\");var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _defineProperty2=_interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _react=_interopRequireWildcard(require(\"react\"));var _invariant=_interopRequireDefault(require(\"invariant\"));var _Animated=_interopRequireDefault(require(\"react-native-web/dist/exports/Animated\"));var _StyleSheet=_interopRequireDefault(require(\"react-native-web/dist/exports/StyleSheet\"));var _View=_interopRequireDefault(require(\"react-native-web/dist/exports/View\"));var _Keyboard=_interopRequireDefault(require(\"react-native-web/dist/exports/Keyboard\"));var _StatusBar=_interopRequireDefault(require(\"react-native-web/dist/exports/StatusBar\"));var _I18nManager=_interopRequireDefault(require(\"react-native-web/dist/exports/I18nManager\"));var _GestureHandler=require(\"./GestureHandler\");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}var DRAG_TOSS=0.05;var IDLE='Idle';var DRAGGING='Dragging';var SETTLING='Settling';var DrawerLayout=function(_Component){(0,_inherits2.default)(DrawerLayout,_Component);function DrawerLayout(_props,context){var _this;(0,_classCallCheck2.default)(this,DrawerLayout);_this=(0,_possibleConstructorReturn2.default)(this,(0,_getPrototypeOf2.default)(DrawerLayout).call(this,_props,context));_this._accessibilityIsModalView=_react.default.createRef();_this._pointerEventsView=_react.default.createRef();_this._panGestureHandler=_react.default.createRef();_this._drawerShown=false;_this._updateAnimatedEvent=function(props,state){var drawerPosition=props.drawerPosition,drawerWidth=props.drawerWidth,drawerType=props.drawerType;var dragXValue=state.dragX,touchXValue=state.touchX,drawerTranslation=state.drawerTranslation,containerWidth=state.containerWidth;var dragX=dragXValue;var touchX=touchXValue;if(drawerPosition!=='left'){dragX=_Animated.default.multiply(new _Animated.default.Value(-1),dragXValue);touchX=_Animated.default.add(new _Animated.default.Value(containerWidth),_Animated.default.multiply(new _Animated.default.Value(-1),touchXValue));touchXValue.setValue(containerWidth);}else{touchXValue.setValue(0);}var translationX=dragX;if(drawerType==='front'){var startPositionX=_Animated.default.add(touchX,_Animated.default.multiply(new _Animated.default.Value(-1),dragX));var dragOffsetFromOnStartPosition=startPositionX.interpolate({inputRange:[drawerWidth-1,drawerWidth,drawerWidth+1],outputRange:[0,0,1]});translationX=_Animated.default.add(dragX,dragOffsetFromOnStartPosition);}_this._openValue=_Animated.default.add(translationX,drawerTranslation).interpolate({inputRange:[0,drawerWidth],outputRange:[0,1],extrapolate:'clamp'});_this._onGestureEvent=_Animated.default.event([{nativeEvent:{translationX:dragXValue,x:touchXValue}}],{useNativeDriver:props.useNativeAnimations});};_this._handleContainerLayout=function(_ref){var nativeEvent=_ref.nativeEvent;_this.setState({containerWidth:nativeEvent.layout.width});};_this._emitStateChanged=function(newState,drawerWillShow){_this.props.onDrawerStateChanged&&_this.props.onDrawerStateChanged(newState,drawerWillShow);};_this._openingHandlerStateChange=function(_ref2){var nativeEvent=_ref2.nativeEvent;if(nativeEvent.oldState===_GestureHandler.State.ACTIVE){_this._handleRelease(nativeEvent);}else if(nativeEvent.state===_GestureHandler.State.ACTIVE){_this._emitStateChanged(DRAGGING,false);if(_this.props.keyboardDismissMode==='on-drag'){_Keyboard.default.dismiss();}if(_this.props.hideStatusBar){_StatusBar.default.setHidden(true,_this.props.statusBarAnimation||'slide');}}};_this._onTapHandlerStateChange=function(_ref3){var nativeEvent=_ref3.nativeEvent;if(_this._drawerShown&&nativeEvent.oldState===_GestureHandler.State.ACTIVE&&_this.props.drawerLockMode!=='locked-open'){_this.closeDrawer();}};_this._handleRelease=function(nativeEvent){var _this$props=_this.props,drawerWidth=_this$props.drawerWidth,drawerPosition=_this$props.drawerPosition,drawerType=_this$props.drawerType;var containerWidth=_this.state.containerWidth;var dragX=nativeEvent.translationX,velocityX=nativeEvent.velocityX,touchX=nativeEvent.x;if(drawerPosition!=='left'){dragX=-dragX;touchX=containerWidth-touchX;velocityX=-velocityX;}var gestureStartX=touchX-dragX;var dragOffsetBasedOnStart=0;if(drawerType==='front'){dragOffsetBasedOnStart=gestureStartX>drawerWidth?gestureStartX-drawerWidth:0;}var startOffsetX=dragX+dragOffsetBasedOnStart+(_this._drawerShown?drawerWidth:0);var projOffsetX=startOffsetX+DRAG_TOSS*velocityX;var shouldOpen=projOffsetX>drawerWidth/2;if(shouldOpen){_this._animateDrawer(startOffsetX,drawerWidth,velocityX);}else{_this._animateDrawer(startOffsetX,0,velocityX);}};_this._updateShowing=function(showing){_this._drawerShown=showing;_this._accessibilityIsModalView.current&&_this._accessibilityIsModalView.current.setNativeProps({accessibilityViewIsModal:showing});_this._pointerEventsView.current&&_this._pointerEventsView.current.setNativeProps({pointerEvents:showing?'auto':'none'});var _this$props2=_this.props,drawerPosition=_this$props2.drawerPosition,minSwipeDistance=_this$props2.minSwipeDistance,edgeWidth=_this$props2.edgeWidth;var fromLeft=drawerPosition==='left';var gestureOrientation=(fromLeft?1:-1)*(_this._drawerShown?-1:1);var hitSlop=fromLeft?{left:0,width:showing?undefined:edgeWidth}:{right:0,width:showing?undefined:edgeWidth};_this._panGestureHandler.current&&_this._panGestureHandler.current.setNativeProps({hitSlop:hitSlop,activeOffsetX:gestureOrientation*minSwipeDistance});};_this._animateDrawer=function(fromValue,toValue,velocity){_this.state.dragX.setValue(0);_this.state.touchX.setValue(_this.props.drawerPosition==='left'?0:_this.state.containerWidth);if(fromValue!==undefined){var nextFramePosition=fromValue;if(_this.props.useNativeAnimations){if(fromValue<toValue&&velocity>0){nextFramePosition=Math.min(fromValue+velocity/60.0,toValue);}else if(fromValue>toValue&&velocity<0){nextFramePosition=Math.max(fromValue+velocity/60.0,toValue);}}_this.state.drawerTranslation.setValue(nextFramePosition);}var willShow=toValue!==0;_this._updateShowing(willShow);_this._emitStateChanged(SETTLING,willShow);if(_this.props.hideStatusBar){_StatusBar.default.setHidden(willShow,_this.props.statusBarAnimation||'slide');}_Animated.default.spring(_this.state.drawerTranslation,{velocity:velocity,bounciness:0,toValue:toValue,useNativeDriver:_this.props.useNativeAnimations}).start(function(_ref4){var finished=_ref4.finished;if(finished){_this._emitStateChanged(IDLE,willShow);if(willShow){_this.props.onDrawerOpen&&_this.props.onDrawerOpen();}else{_this.props.onDrawerClose&&_this.props.onDrawerClose();}}});};_this.openDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,_this.props.drawerWidth,options.velocity?options.velocity:0);_this.forceUpdate();};_this.closeDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,0,options.velocity?options.velocity:0);_this.forceUpdate();};_this._renderOverlay=function(){(0,_invariant.default)(_this._openValue,'should be set');var overlayOpacity=_this._openValue.interpolate({inputRange:[0,1],outputRange:[0,0.7],extrapolate:'clamp'});var dynamicOverlayStyles={opacity:overlayOpacity,backgroundColor:_this.props.overlayColor};return _react.default.createElement(_GestureHandler.TapGestureHandler,{onHandlerStateChange:_this._onTapHandlerStateChange},_react.default.createElement(_Animated.default.View,{pointerEvents:_this._drawerShown?'auto':'none',ref:_this._pointerEventsView,style:[styles.overlay,dynamicOverlayStyles]}));};_this._renderDrawer=function(){var _this$props3=_this.props,drawerBackgroundColor=_this$props3.drawerBackgroundColor,drawerWidth=_this$props3.drawerWidth,drawerPosition=_this$props3.drawerPosition,drawerType=_this$props3.drawerType,drawerContainerStyle=_this$props3.drawerContainerStyle,contentContainerStyle=_this$props3.contentContainerStyle;var fromLeft=drawerPosition==='left';var drawerSlide=drawerType!=='back';var containerSlide=drawerType!=='front';var reverseContentDirection=_I18nManager.default.isRTL?fromLeft:!fromLeft;var dynamicDrawerStyles={backgroundColor:drawerBackgroundColor,width:drawerWidth};var openValue=_this._openValue;(0,_invariant.default)(openValue,'should be set');var containerStyles;if(containerSlide){var containerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:fromLeft?[0,drawerWidth]:[0,-drawerWidth],extrapolate:'clamp'});containerStyles={transform:[{translateX:containerTranslateX}]};}var drawerTranslateX=0;if(drawerSlide){var closedDrawerOffset=fromLeft?-drawerWidth:drawerWidth;drawerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:[closedDrawerOffset,0],extrapolate:'clamp'});}var drawerStyles={transform:[{translateX:drawerTranslateX}],flexDirection:reverseContentDirection?'row-reverse':'row'};return _react.default.createElement(_Animated.default.View,{style:styles.main,onLayout:_this._handleContainerLayout},_react.default.createElement(_Animated.default.View,{style:[drawerType==='front'?styles.containerOnBack:styles.containerInFront,containerStyles,contentContainerStyle]},typeof _this.props.children==='function'?_this.props.children(_this._openValue):_this.props.children,_this._renderOverlay()),_react.default.createElement(_Animated.default.View,{pointerEvents:\"box-none\",ref:_this._accessibilityIsModalView,accessibilityViewIsModal:_this._drawerShown,style:[styles.drawerContainer,drawerStyles,drawerContainerStyle]},_react.default.createElement(_View.default,{style:dynamicDrawerStyles},_this.props.renderNavigationView(_this._openValue))));};_this._setPanGestureRef=function(ref){_this._panGestureHandler.current=ref;_this.props.onGestureRef&&_this.props.onGestureRef(ref);};var _dragX=new _Animated.default.Value(0);var _touchX=new _Animated.default.Value(0);var _drawerTranslation=new _Animated.default.Value(0);_this.state={dragX:_dragX,touchX:_touchX,drawerTranslation:_drawerTranslation,containerWidth:0};_this._updateAnimatedEvent(_props,_this.state);return _this;}(0,_createClass2.default)(DrawerLayout,[{key:\"componentWillUpdate\",value:function componentWillUpdate(props,state){if(this.props.drawerPosition!==props.drawerPosition||this.props.drawerWidth!==props.drawerWidth||this.props.drawerType!==props.drawerType||this.state.containerWidth!==state.containerWidth){this._updateAnimatedEvent(props,state);}}},{key:\"render\",value:function render(){var _this$props4=this.props,drawerPosition=_this$props4.drawerPosition,drawerLockMode=_this$props4.drawerLockMode,edgeWidth=_this$props4.edgeWidth,minSwipeDistance=_this$props4.minSwipeDistance;var fromLeft=drawerPosition==='left';var gestureOrientation=(fromLeft?1:-1)*(this._drawerShown?-1:1);var hitSlop=fromLeft?{left:0,width:this._drawerShown?undefined:edgeWidth}:{right:0,width:this._drawerShown?undefined:edgeWidth};return _react.default.createElement(_GestureHandler.PanGestureHandler,{ref:this._setPanGestureRef,hitSlop:hitSlop,activeOffsetX:gestureOrientation*minSwipeDistance,failOffsetY:[-15,15],onGestureEvent:this._onGestureEvent,onHandlerStateChange:this._openingHandlerStateChange,enabled:drawerLockMode!=='locked-closed'&&drawerLockMode!=='locked-open'},this._renderDrawer());}}]);return DrawerLayout;}(_react.Component);exports.default=DrawerLayout;DrawerLayout.defaultProps={drawerWidth:200,drawerPosition:'left',useNativeAnimations:true,drawerType:'front',edgeWidth:20,minSwipeDistance:3,overlayColor:'black',drawerLockMode:'unlocked'};DrawerLayout.positions={Left:'left',Right:'right'};var styles=_StyleSheet.default.create({drawerContainer:_objectSpread({},_StyleSheet.default.absoluteFillObject,{zIndex:1001,flexDirection:'row'}),containerInFront:_objectSpread({},_StyleSheet.default.absoluteFillObject,{zIndex:1002}),containerOnBack:_objectSpread({},_StyleSheet.default.absoluteFillObject),main:{flex:1,zIndex:0,overflow:'hidden'},overlay:_objectSpread({},_StyleSheet.default.absoluteFillObject,{zIndex:1000})});","map":{"version":3,"sources":["C:/Users/bluej/Desktop/2_2/searchGuide/searchGuide/node_modules/react-native-gesture-handler/DrawerLayout.js"],"names":["DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","props","context","_accessibilityIsModalView","React","createRef","_pointerEventsView","_panGestureHandler","_drawerShown","_updateAnimatedEvent","state","drawerPosition","drawerWidth","drawerType","dragXValue","dragX","touchXValue","touchX","drawerTranslation","containerWidth","Animated","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","_openValue","extrapolate","_onGestureEvent","event","nativeEvent","x","useNativeDriver","useNativeAnimations","_handleContainerLayout","setState","layout","width","_emitStateChanged","newState","drawerWillShow","onDrawerStateChanged","_openingHandlerStateChange","oldState","State","ACTIVE","_handleRelease","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","_onTapHandlerStateChange","drawerLockMode","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","_animateDrawer","_updateShowing","showing","current","setNativeProps","accessibilityViewIsModal","pointerEvents","minSwipeDistance","edgeWidth","fromLeft","gestureOrientation","hitSlop","left","undefined","right","activeOffsetX","fromValue","toValue","velocity","nextFramePosition","Math","min","max","willShow","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","openDrawer","options","forceUpdate","_renderOverlay","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","styles","overlay","_renderDrawer","drawerBackgroundColor","drawerContainerStyle","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","I18nManager","isRTL","dynamicDrawerStyles","openValue","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","main","containerOnBack","containerInFront","children","drawerContainer","renderNavigationView","_setPanGestureRef","ref","onGestureRef","Component","defaultProps","positions","Left","Right","StyleSheet","create","absoluteFillObject","zIndex","flex","overflow"],"mappings":"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","sourcesContent":["// @flow\n\n// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport React, { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n} from 'react-native';\n\nimport { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE = 'Idle';\nconst DRAGGING = 'Dragging';\nconst SETTLING = 'Settling';\n\nexport type PropType = {\n  children: any,\n  drawerBackgroundColor?: string,\n  drawerPosition: 'left' | 'right',\n  drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open',\n  drawerWidth: number,\n  keyboardDismissMode?: 'none' | 'on-drag',\n  onDrawerClose?: Function,\n  onDrawerOpen?: Function,\n  onDrawerStateChanged?: Function,\n  renderNavigationView: (progressAnimatedValue: any) => any,\n  useNativeAnimations: boolean,\n\n  // brand new properties\n  drawerType: 'front' | 'back' | 'slide',\n  edgeWidth: number,\n  minSwipeDistance: number,\n  hideStatusBar?: boolean,\n  statusBarAnimation?: 'slide' | 'none' | 'fade',\n  overlayColor: string,\n  drawerContainerStyle?: any,\n  contentContainerStyle?: any,\n  onGestureRef?: Function,\n\n  // Properties not yet supported\n  // onDrawerSlide?: Function\n};\n\nexport type StateType = {\n  dragX: any,\n  touchX: any,\n  drawerTranslation: any,\n  containerWidth: number,\n};\n\nexport type EventType = {\n  stopPropagation: Function,\n};\n\nexport type DrawerMovementOptionType = {\n  velocity?: number,\n};\n\nexport default class DrawerLayout extends Component<PropType, StateType> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'black',\n    drawerLockMode: 'unlocked',\n  };\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n  _openValue: ?Animated.Interpolation;\n  _onGestureEvent: ?Animated.Event;\n  _accessibilityIsModalView = React.createRef();\n  _pointerEventsView = React.createRef();\n  _panGestureHandler = React.createRef();\n  _drawerShown = false;\n\n  constructor(props: PropType, context: any) {\n    super(props, context);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this._updateAnimatedEvent(props, this.state);\n  }\n\n  componentWillUpdate(props: PropType, state: StateType) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props: PropType, state: StateType) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      );\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n    }\n\n    this._openValue = Animated.add(translationX, drawerTranslation).interpolate(\n      {\n        inputRange: [0, drawerWidth],\n        outputRange: [0, 1],\n        extrapolate: 'clamp',\n      }\n    );\n\n    this._onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      { useNativeDriver: props.useNativeAnimations }\n    );\n  };\n\n  _handleContainerLayout = ({ nativeEvent }) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  _emitStateChanged = (newState: string, drawerWillShow: boolean) => {\n    this.props.onDrawerStateChanged &&\n      this.props.onDrawerStateChanged(newState, drawerWillShow);\n  };\n\n  _openingHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this._emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (\n      this._drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this._drawerShown ? drawerWidth : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth / 2;\n\n    if (shouldOpen) {\n      this._animateDrawer(startOffsetX, drawerWidth, velocityX);\n    } else {\n      this._animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  _updateShowing = (showing: boolean) => {\n    this._drawerShown = showing;\n    this._accessibilityIsModalView.current &&\n      this._accessibilityIsModalView.current.setNativeProps({\n        accessibilityViewIsModal: showing,\n      });\n    this._pointerEventsView.current &&\n      this._pointerEventsView.current.setNativeProps({\n        pointerEvents: showing ? 'auto' : 'none',\n      });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    this._panGestureHandler.current &&\n      this._panGestureHandler.current.setNativeProps({\n        hitSlop,\n        activeOffsetX: gestureOrientation * minSwipeDistance,\n      });\n  };\n\n  _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue !== undefined) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this._updateShowing(willShow);\n    this._emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations,\n    }).start(({ finished }) => {\n      if (finished) {\n        this._emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen && this.props.onDrawerOpen();\n        } else {\n          this.props.onDrawerClose && this.props.onDrawerClose();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(\n      undefined,\n      this.props.drawerWidth,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  _renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this._openValue, 'should be set');\n    const overlayOpacity = this._openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 0.7],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this._drawerShown ? 'auto' : 'none'}\n          ref={this._pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  _renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this._openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this._openValue)\n            : this.props.children}\n          {this._renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this._accessibilityIsModalView}\n          accessibilityViewIsModal={this._drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this._openValue)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  _setPanGestureRef = ref => {\n    this._panGestureHandler.current = ref;\n    this.props.onGestureRef && this.props.onGestureRef(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this._drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this._drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        ref={this._setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._openingHandlerStateChange}\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this._renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n"]},"metadata":{},"sourceType":"script"}